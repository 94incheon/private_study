### 1. 숫자들의 각 자리수 구하기

> - number 를 10 으로 나눈 몫과 나머지
>
> - 몫을 다시 10 으로 나눈 몫과 나머지 
>
> - 반복하면 각 자리수를 구할 수 있다...

```python
number = 5184
res = []

while number != 0:
    a = number % 10
    res.append(a)
    number = number//10

print(res[::-1])    # [5, 1, 8, 4]
```



```python
digits = []
while n != 0:
    n, r = (n // 10), (n % 10) # n : 몫, r : 나머지
    digits.append(r)

print(digits)
```







### 2.정렬

1. **버블정렬** ( Bubble Sort )

> - 인접한 두개 원소 비교하여 자리를 계속 교환하는 방식
>
> - 시간복잡도 O(n^2)
>
> - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.

![image-20200130143718393](img/image-20200130143718393.png)

```python
def BubbleSort(a):    # 정렬할 List
    for i in range(len(a)-1, 0, -1):    # 범위의 끝 위치 ( n-2 )
        for j in range(0, i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]

```





2. 카운팅 정렬 ( Counting Sort )

> - 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여,
>   선형 시간에 정렬하는 효율적인 알고리즘
> - 시간복잡도 O(n + k) : n은 리스트 길이, k는 정수의 최대값
> - **카운트배열을 이용함 [0, 0, 0, 0, 0, 0, 0]**

![image-20200130144329292](img/image-20200130144329292.png)

```python
def Counting_Sort(A, B, k):
# A [1 .. n] -- 입력 배열 (1 to k)
# B [1 .. n] -- 정렬된 배열.
# C [1 .. K] -- 카운트 배열.

C = [0] * k    # 카운트배열을 만들어준다.

for i in range(0, len(B)):
    C[A[i]] += 1
    
for i in range(1, len(C)):
    C[i] += C[i-1]
    
for i in range(len(B)-1, -1, -1):
    B[C[A[i]]-1] = A[i]
    C[A[i]] -= -1
```



- 정렬 알고리즘 비교
  ![image-20200130150631178](img/image-20200130150631178.png)





### 3. 구간합(부분합) [중요]

> 부분합..
>
> `N-M+1` 번 도는 것이 가장 중요

![image-20200203115527955](img/image-20200203115527955.png)



```python
T = int(input())

for tc in range(1, T+1):
    # 갯수, 구간수
    N, M = map(int, input().split())
    d = list(map(int, input().split()))
    
    # 구간합들이 모여있는 arr 생성
    arr = []
    # N-M+1 번 돈다... 중요
    for i in range(N-M+1):
        # 인덱스 + 구간만큼 
        arr.append(sum(d[i:i+M]))

    print('#{} {}'.format(tc, max(arr) - min(arr)))
```





### 4. 셀렉션 알고리즘 ( sorting )

___

> 순서
>
> 1.  처리할 대상 범위에서 최소값을 찾는다.
> 2. 그 값과 범위의 맨 앞에 있는 값을 서로 바꾸는 과정 반복

![image-20200203180547858](img/image-20200203180547858.png)



```

```





### 5. 2차원배열 지그재그 순회

___

```python
n = int(input())
matrix = [[0]*n for i in range(n)]
cnt = 0
for i in range(0, n):
    if i % 2:
        for j in range(n-1, -1, -1):
            cnt += 1
            matrix[i][j] = cnt
    else:
        for j in range(0, n):
            cnt += 1
            matrix[i][j] = cnt
for i in range(0, n):
    for j in range(0, n):
        print(matrix[i][j], end=' ')
    print()
```





### 6. 부분집합 구하기

___

```python
def power_set(items):
    N = len(items)
    # enumerate the 2 ** N possible combinations
    for i in range(2 ** N):
        combo = []
        for j in range(N):
            # test bit jth of integer i
            if (i >> j) % 2 == 1:
                combo.append(items[j])
        yield combo
```

